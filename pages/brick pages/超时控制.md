tag:: #链路超时 #接口响应时间 #监控超时 #数据库连接耗尽

-
- 和超时控制有关的内容，你需要记住以下几点：
	- 超时控制的目标或者说好处。
	  logseq.order-list-type:: number
		- 一是确保客户端能在预期的时间内拿到响应。这其实是用户体验一个重要理念“坏响应也比没响应好”的体现。
		  logseq.order-list-type:: number
		- 二是**及时释放资源**。这其中影响最大的是线程和连接两种资源。释放线程：在超时的情况下，客户端收到了超时响应之后就可以继续往后执行，等执行完毕，这个线程就可以被用于执行别的业务。而如果没有超时控制，那么这个线程就会被一直占有。而像 Go 这种语言，协程会被一直占有。释放连接：连接可以是 RPC 连接，也可以是数据库连接。类似的道理，如果没有拿到响应，客户端会一直占据这个连接。
		  logseq.order-list-type:: number
	- 超时控制的形态。
	  logseq.order-list-type:: number
		- 调用超时控制，比如说你在调用下游接口的时候，为这一次调用设置一个超时时间。
		  logseq.order-list-type:: number
		- **链路超时控制**，是指整条调用链路被一个超时时间控制。比如说你的业务有一条链路是 A 调用 B，B 调用 C。如果链路超时时间是 1s，首先 A 调用 B 的超时时间是 1s，如果 B 收到请求的时候已经过去了 200ms，那么 B 调用 C 的超时时间就不能超过 800ms。
		  logseq.order-list-type:: number
	- 如何确定超时时间？这会是一个面试热点。
	  logseq.order-list-type:: number
		- **根据用户体验**一般的做法就是根据用户体验来决定超时时间。比如说产品经理认为这个用户最多只能在这里等待 300ms，那么你的超时时间就最多设置为 300ms。
		  logseq.order-list-type:: number
		- 根据响应时间在实践中，大多数时候都是根据被**调用接口的响应时间**来确定超时时间。一般情况下，你可以选择使用 99 线或者 999 线来作为超时时间。
		  logseq.order-list-type:: number
		- 压力测试简单来说，你可以通过压力测试来找到被调用接口的 99 线和 999 线。而且压力测试应该尽可能在和线上一样的环境下进行。但是就像我在限流里面提到的，很多公司其实内部没有什么压测环境，也不可能让你停下新功能开发去做压力测试。那么就无法采用压力测试来采集到响应时间数据。
		  logseq.order-list-type:: number
		- 根据代码计算根据代码计算和我在限流里面讲的差不多。假如说你现在有一个接口，里面有三次数据库操作，还有一次访问 Redis 的操作和一次发送消息的操作，那么你接口的响应时间就应该这样计算：接口的响应时间=数据库响应时间×3+Redis响应时间+发送消息的响应时间
		  logseq.order-list-type:: number
	- 超时之后能不能中断业务？
	  logseq.order-list-type:: number
		- 主动检测了超时
		  logseq.order-list-type:: number
		- 如果中间件监听超时时间部分设计得好，它可以帮我们中断一些步骤。
		  logseq.order-list-type:: number
	- 谁来监听超时时间？
	  logseq.order-list-type:: number
		- 一般都是微服务框架客户端来监听超时时间，如果在发起请求之前，就已经超时了，那么框架客户端根本不会发起请求，而是直接返回超时响应
		  logseq.order-list-type:: number
-
- 案例1 没有设置超时时间，导致**数据库连接耗尽**或者线程数量飙升等事故报告
- >正常来说，对任何第三方的调用我都会设置超时时间。如果没有设置超时时间或者超时时间过长，都可能引起资源泄露。比如说早期我们公司就出现过一个事故，某个同事的数据库查询超时时间设置得过长，在数据库性能出现抖动的时候，客户端的所有查询都被长时间阻塞，导致连接池中的连接耗尽。
- 案例2 正常来说，在链路中传递的可以是剩余超时时间，也可以是超时时间戳。
- **链路、协议头、剩余超时时间与超时时间戳**
- >一般超时时间传递的就两种：剩余超时时间或者超时时间戳。比如说剩余 1s，那么就用毫秒作为单位，数值是 1000。这种做法的缺陷就是服务端收到请求之后，要减去请求在网络中传输的时间。比如说 C 收到请求，剩余超时时间是 500ms，如果它知道 B 到 C 之间请求传输要花去 10ms，那么 C 应该用 500ms 减去 10 ms 作为真实的剩余超时时间。不过现实中比较难知道网络传输花了 10ms 这件事。
- >计算网络传输时间最好的方式就是使用性能测试。在模拟线上环境的情况下，让客户端发送平均大小的请求到服务端，采集传输时间，取一个平均值作为网络传输时间。另外一个方式就是不管。比如说正常情况下，A 调用 B，A 和 B 都在同一个机房，网络传输连 1ms 都不用。相比我们超时时间动辄设置为几百毫秒，这一点时间完全可以忽略不计。不过万一服务涉及到了跨机房，尤其是那种机房在两个城市的，城市还离得远的，这部分时间就要计算在内。