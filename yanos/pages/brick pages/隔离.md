tag:: #故障隔离 #BC端隔离

- >本文介绍了微服务架构下的隔离功能对于保证VIP用户体验至关重要。隔离通过资源划分，在不同服务之间建立边界，以防止相互影响，提升可用性、性能和安全性。文章提到了几种隔离策略，包括机房隔离、实例隔离、分组隔离、连接池隔离和线程池隔离，以及第三方依赖隔离。隔离的实际应用对于构建高可用和高性能的微服务架构至关重要，尤其对于复杂、核心和规模庞大的服务。读者可以从中快速了解隔离在微服务架构中的重要性和多种实际应用场景，为构建稳定可靠的系统提供了有益的参考。同时，文章还提供了面试准备的建议，包括如何在面试中展示对隔离的理解和应用，以及如何将隔离作为构建高可用和高性能微服务的手段之一。文章还强调了隔离的缺点，如资源浪费和不均衡问题，以及亮点方案，如慢任务隔离和制作库与线上库分离。
- 出现故障的时候，隔离可以把影响限制在一个可以忍受的范围内。
- 隔离策略主要是为了达到 3 个目的
	- 提升可用性，也就是说防止被影响或防止影响别人。这部分也叫做**故障隔离**。
	- 提升性能，这是隔离和熔断、降级、限流不同的地方，**一些隔离方案能够提高系统性能**，而且有时候甚至能做到数量级提升。
	- 提升安全性，也就是为安全性比较高的系统提供单独的集群、使用更加严苛的权限控制、迎合当地的数据合规要求等。
- **一般的原则是核心与核心隔离，核心与非核心隔离。**
- 机房隔离
- 实例隔离
- 分组隔离
	- B 端一个组，C 端一个组。普通用户一个组，VIP 用户一个组。读接口一个组，写接口一个组。这种也叫做读写隔离。比如说在生产内容的业务里面，没有实行制作库和线上库分离的话，那么就可以简单地把读取内容划分成一个组，编辑内容划分成另外一个组。快接口一个组，慢接口一个组。这个和前面的读写隔离可能会重叠，因为一般来说读接口就是比较快。
- 连接池隔离和线程池隔离
	- 一般的做法都是给核心服务单独的连接池和线程池。这么做对于性能的改进也是很有帮助的，尤其是连接池隔离。
	- 容器化本身也属于**进程隔离**的一种
- 第三方依赖隔离
	- 越是关键的业务，业务上越是关键的路径，就越要小心隔离。比如说我们经常听到某家公司因为 Redis 共用，导致某个业务把 Redis 搞崩了，结果其他更加重要的服务也一起崩溃了的事故报告。
-
-
- 相关话题：
- >连接池和线程池相关的问题，你可以把隔离作为例子，证明你在连接池和线程池的使用上是很有心得体会的。
  如何处理热点？你可以回答隔离，一方面可以提升性能，另一方面可以防止热点被别的业务影响，同时也可以防止别的业务影响到热点。
  某个第三方中间件，比如 Redis 崩溃之后怎么办？那这个时候你可以强调给核心业务不同的 Redis 集群，能够一定程度上缓解这个问题，毕竟只要核心业务的 Redis 没有崩溃，不重要的业务的 Redis 崩溃也不是那么难以接受。
- **案例1 缺乏隔离机制：**
- >之前我在公司的时候就遇到过一个事故。当时我们的服务原本运行得很好，结果突然之间 Redis 就卡住了，导致我们的 Redis 请求大部分超时，请求都落到了数据库上，数据库负载猛增，导致数据库查询也超时。后来运维排查，确认了 Redis 在那段时间因为别的业务上线了一个新功能，这个功能会批量计算数据，产生的结果会存储在 Redis。但是这个结果非常庞大，所以在这个功能运行的时候，Redis 就相当于在频繁操作大对象。也不仅仅是我们，所有使用那个 Redis 的业务都受到了影响。后来我们再使用 Redis 的时候，就分成了核心与非核心。核心 Redis 有更加严格的接入机制和代码 review 机制，而非核心的就比较随意。不仅如此，我们还为高并发的服务设计了数据库限流，防止再来一次 Redis 失效导致 MySQL 被打崩的事故。
- 那隔离就没有什么缺点了吗？当然有，关键词就是**贵且浪费**。
- **案例2 慢任务隔离**
	- 之前我们遇到过一个 Bug，就是我们的定时任务总不能及时得到调度。后来我们加上监控之后，发现是因为存在少数执行很慢的任务，将线程池中的线程都占满了。所以我后来引入了线程池隔离机制，核心就是让慢任务在一个专门的线程池里面执行。 我准备了两个线程池，一个线程池专门执行慢任务，一个是执行快任务。而当任务开始执行的时候，先在快任务线程池里执行一些简单的逻辑，确定任务规模，这一步也就是为了识别慢任务。比如说根据要处理的数据量的大小，分出慢任务。如果是快任务，就继续执行。否则，转交给慢任务线程池。
- **制作库与线上库分离**
	- 在我们的业务里面，采用了制作库和线上库分离的方案来保证业务的可用性和性能。大体来说，作者在 B 端写作，操作的都是制作库，这个过程 C 端读者是没有任何感知的。当作者点击发布之后，就会开始同步给审核，审核通过之后就会同步给线上库。在同步给线上库的时候，我们还会直接同步到缓存，这样作者的关注者阅读文章的时候就会直接命中缓存。 后面如果作者要修改文章，修改的也是 B 端制作库，等他修改完毕，就会再次提交审核。审核完成之前，C 端用户看到的都是历史版本，这样 B 端和 C 端隔离保证了两边的用户体验。同时拆成两个数据库之后，C 端线上库几乎都是读流量，性能很好。
-
- #+BEGIN_IMPORTANT
  总结：机房隔离、实例隔离、分组隔离、连接池隔离和线程池隔离，以及第三方依赖隔离，并且给出了两个方案：慢任务隔离和制作库与线上库分离。
  #+END_IMPORTANT
-